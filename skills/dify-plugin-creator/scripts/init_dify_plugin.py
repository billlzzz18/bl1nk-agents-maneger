#!/usr/bin/env python3
"""
Dify Plugin Creator - Initialize new plugin scaffold
Creates production-ready plugin structure with all necessary components
"""

import argparse
import json
import sys
from pathlib import Path
from datetime import datetime
import shutil
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

PLUGIN_TYPES = {
    'document_processor': {
        'description': 'Process documents (CSV, Excel, PDF, JSON)',
        'tools': ['parse', 'validate', 'transform'],
        'base_imports': ['pandas', 'openpyxl', 'pypdf']
    },
    'api_wrapper': {
        'description': 'Wrap external APIs',
        'tools': ['call_api', 'format_response', 'handle_errors'],
        'base_imports': ['requests', 'httpx']
    },
    'data_transformer': {
        'description': 'Transform and enrich data',
        'tools': ['map_data', 'aggregate', 'enrich'],
        'base_imports': ['pandas', 'numpy']
    },
    'contact_manager': {
        'description': 'Manage contact information',
        'tools': ['store_contact', 'retrieve_contact', 'search_contacts'],
        'base_imports': ['sqlalchemy', 'pydantic']
    },
    'rag_component': {
        'description': 'Retrieval-Augmented Generation',
        'tools': ['retrieve', 'rank', 'rerank'],
        'base_imports': ['langchain', 'embeddings']
    }
}

class DifyPluginGenerator:
    """Generate Dify plugin structure"""
    
    def __init__(self, plugin_name: str, author: str, plugin_type: str, 
                 output_dir: str = '.', version: str = '0.1.0'):
        self.plugin_name = plugin_name
        self.author = author
        self.plugin_type = plugin_type
        self.output_dir = Path(output_dir)
        self.version = version
        self.plugin_dir = self.output_dir / plugin_name
        self.plugin_config = PLUGIN_TYPES.get(plugin_type, {})
    
    def generate(self) -> bool:
        """Generate plugin structure"""
        try:
            logger.info(f"Creating Dify plugin: {self.plugin_name}")
            
            # Create directories
            self._create_directories()
            
            # Generate files
            self._generate_manifest()
            self._generate_provider()
            self._generate_context_manager()
            self._generate_tool_files()
            self._generate_tests()
            self._generate_docs()
            self._generate_config_files()
            
            logger.info(f"✓ Plugin created successfully at {self.plugin_dir}")
            return True
        
        except Exception as e:
            logger.error(f"Error generating plugin: {str(e)}")
            return False
    
    def _create_directories(self):
        """Create plugin directory structure"""
        dirs = [
            self.plugin_dir,
            self.plugin_dir / 'src',
            self.plugin_dir / 'src' / 'tools',
            self.plugin_dir / 'src' / 'models',
            self.plugin_dir / 'tests',
            self.plugin_dir / 'docs',
            self.plugin_dir / 'scripts',
        ]
        
        for dir_path in dirs:
            dir_path.mkdir(parents=True, exist_ok=True)
    
    def _generate_manifest(self):
        """Generate manifest.yaml"""
        manifest = {
            'identity': {
                'author': self.author,
                'name': self.plugin_name,
                'label': {
                    'en_US': self._humanize(self.plugin_name),
                },
                'description': {
                    'en_US': self.plugin_config.get('description', 'A Dify plugin'),
                },
                'icon': 'icon.svg',
                'version': self.version,
            },
            'tools': [f'tools/{tool_name}.yaml' for tool_name in self.plugin_config.get('tools', [])],
            'features': self.plugin_config.get('tools', []),
            'extra': {
                'python': {
                    'source': 'src/provider.py'
                }
            }
        }
        
        import yaml
        with open(self.plugin_dir / 'manifest.yaml', 'w') as f:
            yaml.dump(manifest, f, default_flow_style=False)
        
        logger.info("✓ Generated manifest.yaml")
    
    def _generate_provider(self):
        """Generate main provider.py"""
        provider_code = f'''"""
{self.plugin_name} - Dify Plugin Provider
Generated by Dify Plugin Creator Framework
"""

from typing import Any, Dict, Optional
import json
import logging
from datetime import datetime

from dify_plugin import ToolProvider
from dify_plugin.errors.tool import ToolProviderCredentialValidationError

from .context_manager import PluginContext
from .tools import *

logger = logging.getLogger(__name__)


class {self._camel_case(self.plugin_name)}Provider(ToolProvider):
    """
    {self.plugin_name} Dify Plugin Provider
    
    Type: {self.plugin_type}
    Author: {self.author}
    Version: {self.version}
    """
    
    def __init__(self):
        super().__init__()
        self.context = PluginContext()
        self.tools = self._initialize_tools()
    
    def _initialize_tools(self) -> Dict[str, Any]:
        """Initialize all available tools"""
        return {{
{chr(10).join(f'            "{tool}": self.{tool},' for tool in self.plugin_config.get("tools", []))}
        }}
    
    def _validate_credentials(self, credentials: dict[str, Any]) -> None:
        """Validate provider credentials"""
        try:
            if credentials and isinstance(credentials, dict):
                pass
        except Exception as e:
            raise ToolProviderCredentialValidationError(str(e))
    
    def invoke(self, tool_name: str, parameters: dict[str, Any]) -> dict[str, Any]:
        """Invoke tool with parameters"""
        try:
            if tool_name not in self.tools:
                return {{'status': 'error', 'error': f'Unknown tool: {{tool_name}}'}}
            
            self.context.set_current_operation(tool_name)
            self.context.add_metadata('parameters', parameters)
            
            result = self.tools[tool_name](parameters)
            
            self.context.save_state()
            return result
        
        except Exception as e:
            logger.error(f"Error invoking {{tool_name}}: {{str(e)}}")
            return {{
                'status': 'error',
                'error': str(e),
                'context': self.context.to_dict()
            }}
    
    def get_tool_schemas(self) -> Dict[str, Any]:
        """Get schemas for all tools"""
        return {{
{chr(10).join(f'            "{tool}": self._get_schema_{tool}(),' for tool in self.plugin_config.get("tools", []))}
        }}
    
    # Tool implementations
{chr(10).join(self._generate_tool_methods())}
'''
        
        provider_file = self.plugin_dir / 'src' / 'provider.py'
        with open(provider_file, 'w') as f:
            f.write(provider_code)
        
        logger.info("✓ Generated provider.py")
    
    def _generate_tool_methods(self) -> list:
        """Generate placeholder tool methods"""
        methods = []
        for tool in self.plugin_config.get('tools', []):
            method = f'''    def {tool}(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        {self._humanize(tool)} tool
        
        Parameters:
            parameters: Tool parameters
        
        Returns:
            Tool result
        """
        try:
            # TODO: Implement {tool} logic
            return {{
                'status': 'success',
                'data': {{}},
                'tool': '{tool}'
            }}
        except Exception as e:
            logger.error(f"Error in {tool}: {{str(e)}}")
            return {{'status': 'error', 'error': str(e)}}
    
    def _get_schema_{tool}(self) -> Dict[str, Any]:
        """Get schema for {tool}"""
        return {{
            'name': '{tool}',
            'description': 'TODO: Add description',
            'parameters': {{
                'type': 'object',
                'properties': {{}},
                'required': []
            }}
        }}
'''
            methods.append(method)
        
        return methods
    
    def _generate_context_manager(self):
        """Generate context_manager.py"""
        context_code = f'''"""
Context Manager for {self.plugin_name} Plugin
Handles state preservation and context management across tool invocations
"""

from typing import Any, Dict, Optional
from datetime import datetime
from pathlib import Path
import json
import logging

logger = logging.getLogger(__name__)


class PluginContext:
    """Manages plugin execution context"""
    
    def __init__(self, persistent: bool = True, storage_dir: str = '.plugin_context'):
        self.persistent = persistent
        self.storage_dir = Path(storage_dir)
        if self.persistent:
            self.storage_dir.mkdir(exist_ok=True)
        
        self.current_operation: Optional[str] = None
        self.metadata: Dict[str, Any] = {{}}
        self.state_history: list = []
        self.error_log: list = []
    
    def set_current_operation(self, operation: str):
        """Set current operation"""
        self.current_operation = operation
    
    def add_metadata(self, key: str, value: Any):
        """Add metadata"""
        self.metadata[key] = value
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert context to dictionary"""
        return {{
            'current_operation': self.current_operation,
            'metadata': self.metadata,
            'state_history': self.state_history,
            'errors': len(self.error_log),
            'timestamp': datetime.now().isoformat()
        }}
    
    def save_state(self):
        """Save state to disk if persistent"""
        if self.persistent:
            try:
                state_file = self.storage_dir / 'context_state.json'
                with open(state_file, 'w') as f:
                    json.dump(self.to_dict(), f, indent=2, default=str)
            except Exception as e:
                logger.error(f"Error saving state: {{str(e)}}")
    
    def load_state(self):
        """Load state from disk if persistent"""
        if self.persistent:
            try:
                state_file = self.storage_dir / 'context_state.json'
                if state_file.exists():
                    with open(state_file, 'r') as f:
                        state = json.load(f)
                        self.current_operation = state.get('current_operation')
                        self.metadata = state.get('metadata', {{}})
            except Exception as e:
                logger.error(f"Error loading state: {{str(e)}}")
'''
        
        context_file = self.plugin_dir / 'src' / 'context_manager.py'
        with open(context_file, 'w') as f:
            f.write(context_code)
        
        logger.info("✓ Generated context_manager.py")
    
    def _generate_tool_files(self):
        """Generate tool implementation files"""
        init_file = self.plugin_dir / 'src' / 'tools' / '__init__.py'
        with open(init_file, 'w') as f:
            f.write('"""Tools module"""\n')
        
        for tool in self.plugin_config.get('tools', []):
            tool_file = self.plugin_dir / 'src' / 'tools' / f'{tool}.py'
            with open(tool_file, 'w') as f:
                f.write(f'"""Tool: {tool}"""\n\ndef {tool}(parameters):\n    pass\n')
        
        logger.info("✓ Generated tool files")
    
    def _generate_tests(self):
        """Generate test files"""
        init_file = self.plugin_dir / 'tests' / '__init__.py'
        with open(init_file, 'w') as f:
            f.write('"""Tests module"""\n')
        
        test_file = self.plugin_dir / 'tests' / 'test_provider.py'
        with open(test_file, 'w') as f:
            f.write(f'''"""
Tests for {self.plugin_name} Provider
"""

import pytest
from src.provider import {self._camel_case(self.plugin_name)}Provider


class Test{self._camel_case(self.plugin_name)}Provider:
    """Test cases for plugin provider"""
    
    def setup_method(self):
        """Setup test provider"""
        self.provider = {self._camel_case(self.plugin_name)}Provider()
    
    def test_initialization(self):
        """Test provider initialization"""
        assert self.provider is not None
    
    def test_get_tool_schemas(self):
        """Test tool schemas"""
        schemas = self.provider.get_tool_schemas()
        assert isinstance(schemas, dict)
''')
        
        logger.info("✓ Generated test files")
    
    def _generate_docs(self):
        """Generate documentation"""
        readme = self.plugin_dir / 'README.md'
        with open(readme, 'w') as f:
            f.write(f'''# {self._humanize(self.plugin_name)}

A Dify plugin for {self.plugin_config.get('description', 'data processing')}.

## Installation

```bash
pip install -r requirements.txt
```

## Usage

Add to your Dify configuration:

```yaml
tools:
  - name: {self.plugin_name}
    provider: {self._camel_case(self.plugin_name)}Provider
```

## Tools

{chr(10).join(f"- **{tool}**: " for tool in self.plugin_config.get('tools', []))}

## Author

{self.author}

## Version

{self.version}
''')
        
        api_file = self.plugin_dir / 'docs' / 'API.md'
        with open(api_file, 'w') as f:
            f.write(f'# API Reference\n\nTools:\n\n')
            for tool in self.plugin_config.get('tools', []):
                f.write(f'## {self._humanize(tool)}\n\n')
        
        logger.info("✓ Generated documentation")
    
    def _generate_config_files(self):
        """Generate configuration files"""
        req_file = self.plugin_dir / 'requirements.txt'
        with open(req_file, 'w') as f:
            f.write('dify-plugin>=0.1.0\n')
            for pkg in self.plugin_config.get('base_imports', []):
                f.write(f'{pkg}\n')
        
        init_file = self.plugin_dir / 'src' / '__init__.py'
        with open(init_file, 'w') as f:
            f.write('"""Plugin source code"""\n')
        
        logger.info("✓ Generated configuration files")
    
    @staticmethod
    def _humanize(name: str) -> str:
        """Convert snake_case to Title Case"""
        return ' '.join(word.capitalize() for word in name.split('_'))
    
    @staticmethod
    def _camel_case(name: str) -> str:
        """Convert snake_case to CamelCase"""
        return ''.join(word.capitalize() for word in name.split('_'))


def main():
    parser = argparse.ArgumentParser(description='Dify Plugin Creator')
    parser.add_argument('--name', required=True, help='Plugin name')
    parser.add_argument('--author', required=True, help='Author name')
    parser.add_argument('--type', required=True, choices=PLUGIN_TYPES.keys(), help='Plugin type')
    parser.add_argument('--output-dir', default='.', help='Output directory')
    parser.add_argument('--version', default='0.1.0', help='Initial version')
    
    args = parser.parse_args()
    
    generator = DifyPluginGenerator(
        plugin_name=args.name,
        author=args.author,
        plugin_type=args.type,
        output_dir=args.output_dir,
        version=args.version
    )
    
    if generator.generate():
        print(f"\n✓ Plugin created at: {generator.plugin_dir}")
        sys.exit(0)
    else:
        print("\n✗ Plugin creation failed")
        sys.exit(1)


if __name__ == '__main__':
    main()
