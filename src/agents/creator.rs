// src/agents/creator.rs
//! Agent Creator - Generates agent specifications from natural language requirements

use anyhow::{Context, Result, bail};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::fs;
use std::path::Path;

/// Agent specification generated by Agent Creator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentSpec {
    pub identifier: String,
    pub name: String,
    pub description: String,
    pub when_to_use: String,
    pub system_prompt: String,
    pub model: String,
    pub color: String,
    pub tools: Vec<String>,
    pub examples: Vec<TriggerExample>,
    pub capabilities: Vec<String>,
    pub priority: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TriggerExample {
    pub context: String,
    pub user_message: String,
    pub assistant_response: String,
    pub commentary: String,
}

/// Agent Creator - generates agent specifications
pub struct AgentCreator {
    template_dir: String,
    output_dir: String,
}

impl AgentCreator {
    pub fn new(template_dir: String, output_dir: String) -> Self {
        Self {
            template_dir,
            output_dir,
        }
    }

    /// Main entry point: create agent from user requirements
    pub async fn create_agent(
        &self,
        requirements: &str,
        context: Option<Value>,
    ) -> Result<AgentSpec> {
        tracing::info!("ðŸ¤– Agent Creator: Generating agent from requirements");
        tracing::debug!("Requirements: {}", requirements);

        // Ensure output directory exists
        fs::create_dir_all(&self.output_dir)
            .context("Failed to create output directory")?;

        // 1. Parse requirements
        let parsed = self.parse_requirements(requirements)?;
        tracing::debug!("Parsed requirements: {:?}", parsed);

        // 2. Generate identifier
        let identifier = self.generate_identifier(&parsed.purpose)?;
        tracing::info!("Generated identifier: {}", identifier);

        // 3. Create system prompt
        let system_prompt = self.create_system_prompt(&parsed)?;

        // 4. Generate examples
        let examples = self.generate_examples(&parsed)?;

        // 5. Select model and color
        let model = self.select_model(&parsed);
        let color = self.select_color(&parsed);

        // 6. Build spec
        let spec = AgentSpec {
            identifier: identifier.clone(),
            name: parsed.name.clone(),
            description: parsed.description.clone(),
            when_to_use: parsed.when_to_use.clone(),
            system_prompt,
            model,
            color,
            tools: parsed.tools.clone(),
            examples,
            capabilities: vec![parsed.purpose.clone()],
            priority: 100,
        };

        // 7. Validate
        self.validate_spec(&spec)?;

        // 8. Write to file
        self.write_agent_file(&spec)?;

        tracing::info!("âœ… Agent '{}' created successfully", identifier);
        Ok(spec)
    }

    /// Parse user requirements into structured data
    fn parse_requirements(&self, requirements: &str) -> Result<ParsedRequirements> {
        // Extract key information from natural language
        let requirements_lower = requirements.to_lowercase();
        
        // Determine purpose
        let purpose = if requirements_lower.contains("review") || requirements_lower.contains("analyze") {
            "code review and analysis"
        } else if requirements_lower.contains("generate") || requirements_lower.contains("create") {
            "code generation"
        } else if requirements_lower.contains("test") {
            "test generation"
        } else if requirements_lower.contains("validate") || requirements_lower.contains("check") {
            "validation"
        } else {
            "general task execution"
        };

        // Determine complexity
        let complexity = if requirements.split_whitespace().count() > 20 {
            AgentComplexity::Complex
        } else if requirements.split_whitespace().count() > 10 {
            AgentComplexity::Medium
        } else {
            AgentComplexity::Simple
        };

        // Extract tools if mentioned
        let tools = if requirements_lower.contains("read") && requirements_lower.contains("write") {
            vec!["Read".to_string(), "Write".to_string()]
        } else if requirements_lower.contains("read") {
            vec!["Read".to_string()]
        } else if requirements_lower.contains("write") {
            vec!["Write".to_string()]
        } else {
            vec![] // All tools
        };

        Ok(ParsedRequirements {
            name: self.extract_agent_name(requirements)?,
            purpose: purpose.to_string(),
            description: format!("Use this agent when {}", requirements),
            when_to_use: requirements.to_string(),
            tools,
            complexity,
        })
    }

    /// Extract agent name from requirements
    fn extract_agent_name(&self, requirements: &str) -> Result<String> {
        // Simple heuristic: take first few meaningful words
        let words: Vec<&str> = requirements
            .split_whitespace()
            .filter(|w| !["a", "an", "the", "that", "this", "creates", "generates"].contains(&w.to_lowercase().as_str()))
            .take(3)
            .collect();

        if words.is_empty() {
            return Ok("Generated Agent".to_string());
        }

        Ok(words.join(" ")
            .split(|c: char| !c.is_alphanumeric() && c != ' ')
            .collect::<Vec<&str>>()
            .join(" ")
            .trim()
            .to_string())
    }

    /// Generate agent identifier from purpose
    fn generate_identifier(&self, purpose: &str) -> Result<String> {
        let purpose_lower = purpose.to_lowercase();
        let words: Vec<&str> = purpose_lower
            .split_whitespace()
            .filter(|w| w.len() > 2) // Skip short words
            .take(4)
            .collect();
        
        let mut identifier = words.join("-");
        
        // Remove special characters, keep only alphanumeric and hyphens
        identifier = identifier
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '-')
            .collect();
        
        // Remove consecutive hyphens
        while identifier.contains("--") {
            identifier = identifier.replace("--", "-");
        }
        
        // Trim hyphens from ends
        identifier = identifier.trim_matches('-').to_string();
        
        // Ensure valid length (3-50)
        if identifier.len() < 3 {
            identifier = format!("{}-agent", identifier);
        }
        if identifier.len() > 50 {
            identifier.truncate(50);
            identifier = identifier.trim_end_matches('-').to_string();
        }
        
        // Ensure doesn't start with number
        if identifier.chars().next().map(|c| c.is_numeric()).unwrap_or(false) {
            identifier = format!("agent-{}", identifier);
        }
        
        Ok(identifier)
    }

    /// Create comprehensive system prompt
    fn create_system_prompt(&self, parsed: &ParsedRequirements) -> Result<String> {
        let template = format!(
r#"You are an expert {} agent with deep domain knowledge.

## Your Core Mission

{} - This is your primary responsibility and expertise.

## Core Responsibilities

1. **Primary Function**: {}
   - Execute tasks with precision and expertise
   - Apply domain-specific best practices
   - Ensure high-quality outputs

2. **Quality Assurance**: 
   - Verify accuracy and correctness
   - Ensure completeness of deliverables
   - Maintain clarity and professionalism

3. **Error Handling**:
   - Detect and handle edge cases gracefully
   - Provide clear error messages
   - Suggest corrective actions when needed

## Operational Process

When you receive a task, follow this systematic approach:

### Step 1: Analysis
- Carefully read and understand the request
- Identify key requirements and constraints
- Note any ambiguities or missing information

### Step 2: Validation
- Verify all necessary inputs are provided
- Check for potential conflicts or issues
- Ask clarifying questions if needed

### Step 3: Execution
- Apply your expertise to the task
- Follow established best practices
- Use appropriate tools and techniques

### Step 4: Verification
- Review your output for accuracy
- Check for completeness
- Ensure quality standards are met

### Step 5: Delivery
- Present results in clear, structured format
- Highlight key points and decisions
- Provide context and explanations

## Output Standards

Your responses should always:
- Be well-structured with clear sections
- Use appropriate formatting (headers, lists, code blocks)
- Include examples when helpful
- Provide actionable next steps
- Be concise yet comprehensive

## Edge Case Handling

**Ambiguous Requests**: Ask specific clarifying questions before proceeding.

**Missing Information**: Clearly state what information is needed and why.

**Errors or Conflicts**: Explain the issue clearly and suggest specific solutions.

**Out of Scope**: Politely indicate if the request falls outside your expertise.

## Communication Style

- Professional yet approachable
- Clear and direct
- Helpful and constructive
- Precise with technical details
- Patient with follow-up questions

Remember: Your goal is to provide exceptional service through expertise, precision, and clarity.
"#,
            parsed.name,
            parsed.purpose,
            parsed.when_to_use
        );

        Ok(template)
    }

    /// Generate trigger examples
    fn generate_examples(&self, parsed: &ParsedRequirements) -> Result<Vec<TriggerExample>> {
        let identifier_guess = self.generate_identifier(&parsed.purpose)?;
        
        let examples = vec![
            TriggerExample {
                context: format!("User needs help with {}", parsed.purpose),
                user_message: parsed.when_to_use.clone(),
                assistant_response: format!(
                    "I'll use the {} agent to help with this task.",
                    identifier_guess
                ),
                commentary: format!(
                    "User requesting {}, trigger the {} agent.",
                    parsed.purpose,
                    identifier_guess
                ),
            },
            TriggerExample {
                context: "Proactive scenario".to_string(),
                user_message: format!("Can you help with {}?", parsed.purpose),
                assistant_response: format!(
                    "Yes! I'll invoke the {} agent for this.",
                    identifier_guess
                ),
                commentary: format!(
                    "Task matches {} capability, trigger agent proactively.",
                    parsed.purpose
                ),
            },
        ];

        Ok(examples)
    }

    /// Select appropriate model based on complexity
    fn select_model(&self, parsed: &ParsedRequirements) -> String {
        match parsed.complexity {
            AgentComplexity::Simple => "haiku".to_string(),
            AgentComplexity::Medium => "sonnet".to_string(),
            AgentComplexity::Complex => "opus".to_string(),
        }
    }

    /// Select color based on agent purpose
    fn select_color(&self, parsed: &ParsedRequirements) -> String {
        let purpose_lower = parsed.purpose.to_lowercase();
        
        if purpose_lower.contains("review") || purpose_lower.contains("analyz") {
            "blue".to_string()
        } else if purpose_lower.contains("generat") || purpose_lower.contains("creat") {
            "green".to_string()
        } else if purpose_lower.contains("validat") || purpose_lower.contains("check") {
            "yellow".to_string()
        } else if purpose_lower.contains("security") || purpose_lower.contains("critical") {
            "red".to_string()
        } else if purpose_lower.contains("transform") || purpose_lower.contains("convert") {
            "magenta".to_string()
        } else {
            "cyan".to_string()
        }
    }

    /// Validate agent specification
    fn validate_spec(&self, spec: &AgentSpec) -> Result<()> {
        // Check identifier length
        if spec.identifier.len() < 3 || spec.identifier.len() > 50 {
            bail!(
                "Identifier '{}' must be 3-50 characters (got {})",
                spec.identifier,
                spec.identifier.len()
            );
        }

        // Check lowercase and hyphens only
        if !spec.identifier.chars().all(|c| c.is_lowercase() || c.is_numeric() || c == '-') {
            bail!("Identifier '{}' must be lowercase with hyphens only", spec.identifier);
        }

        // Check doesn't start with hyphen or number
        if spec.identifier.starts_with('-') || spec.identifier.chars().next().map(|c| c.is_numeric()).unwrap_or(false) {
            bail!("Identifier '{}' cannot start with hyphen or number", spec.identifier);
        }

        // Check system prompt length
        let word_count = spec.system_prompt.split_whitespace().count();
        if word_count < 50 {
            tracing::warn!("System prompt is very short ({} words)", word_count);
        }

        // Check examples
        if spec.examples.is_empty() {
            bail!("Agent must have at least one trigger example");
        }

        tracing::info!("âœ… Agent spec validation passed");
        Ok(())
    }

    /// Write agent specification to TOML file
    fn write_agent_file(&self, spec: &AgentSpec) -> Result<()> {
        let filename = format!("{}/{}.toml", self.output_dir, spec.identifier);
        
        let examples_toml: Vec<String> = spec.examples.iter().map(|ex| {
            format!(
r#"[[agent.examples]]
context = "{}"
user_message = "{}"
assistant_response = "{}"
commentary = "{}"
"#,
                ex.context,
                ex.user_message.replace('"', "\\\""),
                ex.assistant_response.replace('"', "\\\""),
                ex.commentary.replace('"', "\\\"")
            )
        }).collect();

        let content = format!(
r#"# Agent: {}
# Auto-generated by BL1NK Agent Creator

[agent]
id = "{}"
name = "{}"
type = "generated"
enabled = true
priority = {}

[agent.config]
model = "{}"
color = "{}"
tools = {:?}
capabilities = {:?}

[agent.metadata]
description = """
{}
"""

when_to_use = """
{}
"""

system_prompt = """
{}
"""

# Trigger Examples
{}
"#,
            spec.name,
            spec.identifier,
            spec.name,
            spec.priority,
            spec.model,
            spec.color,
            spec.tools,
            spec.capabilities,
            spec.description,
            spec.when_to_use,
            spec.system_prompt,
            examples_toml.join("\n")
        );

        fs::write(&filename, content)
            .with_context(|| format!("Failed to write agent file: {}", filename))?;

        tracing::info!("ðŸ“ Agent file written: {}", filename);
        Ok(())
    }

    /// Check if agent file already exists
    pub fn agent_exists(&self, identifier: &str) -> bool {
        let filename = format!("{}/{}.toml", self.output_dir, identifier);
        Path::new(&filename).exists()
    }
}

/// Parsed requirements from user input
#[derive(Debug)]
struct ParsedRequirements {
    name: String,
    purpose: String,
    description: String,
    when_to_use: String,
    tools: Vec<String>,
    complexity: AgentComplexity,
}

#[derive(Debug)]
enum AgentComplexity {
    Simple,
    Medium,
    Complex,
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_agent_creation() {
        let temp = TempDir::new().unwrap();
        let output_dir = temp.path().to_str().unwrap().to_string();

        let creator = AgentCreator::new(
            "templates".to_string(),
            output_dir.clone(),
        );

        let spec = creator.create_agent(
            "Create an agent that reviews code for quality issues",
            None,
        ).await.unwrap();

        assert!(spec.identifier.len() >= 3);
        assert!(spec.identifier.len() <= 50);
        assert!(!spec.system_prompt.is_empty());
        assert!(!spec.examples.is_empty());

        // Verify file was created
        assert!(creator.agent_exists(&spec.identifier));
    }

    #[test]
    fn test_identifier_generation() {
        let creator = AgentCreator::new("".to_string(), "".to_string());

        let id = creator.generate_identifier("code review and analysis").unwrap();
        assert!(id.len() >= 3);
        assert!(id.chars().all(|c| c.is_lowercase() || c.is_numeric() || c == '-'));
    }

    #[test]
    fn test_color_selection() {
        let creator = AgentCreator::new("".to_string(), "".to_string());

        let parsed = ParsedRequirements {
            name: "Test".to_string(),
            purpose: "code review".to_string(),
            description: "".to_string(),
            when_to_use: "".to_string(),
            tools: vec![],
            complexity: AgentComplexity::Medium,
        };

        assert_eq!(creator.select_color(&parsed), "blue");
    }
}
