{"$message_type":"diagnostic","message":"file not found for module `agents`","code":{"code":"E0583","explanation":"A file wasn't found for an out-of-line module.\n\nErroneous code example:\n\n```compile_fail,E0583\nmod file_that_doesnt_exist; // error: file not found for module\n\nfn main() {}\n```\n\nPlease be sure that a file corresponding to the module exists. If you\nwant to use a module named `file_that_doesnt_exist`, you need to have a file\nnamed `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\nsame directory.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":21,"byte_end":32,"line_start":3,"line_end":3,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"mod agents;","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"to create the module `agents`, create file \"src/agents.rs\" or \"src/agents/mod.rs\"","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"if there is a `mod agents` elsewhere in the crate already, import it with `use crate::...` instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0583]\u001b[0m\u001b[1m: file not found for module `agents`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:3:1\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m mod agents;\n  \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: to create the module `agents`, create file \"src/agents.rs\" or \"src/agents/mod.rs\"\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: if there is a `mod agents` elsewhere in the crate already, import it with `use crate::...` instead\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::collections::HashMap`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/config.rs","byte_start":72,"byte_end":97,"line_start":3,"line_end":3,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/config.rs","byte_start":68,"byte_end":99,"line_start":3,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":31},{"text":"use std::fs;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `std::collections::HashMap`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/config.rs:3:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::collections::HashMap;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unexpected `cfg` condition value: `bundle-pmat`","code":{"code":"unexpected_cfgs","explanation":null},"level":"warning","spans":[{"file_name":"src/config.rs","byte_start":5289,"byte_end":5312,"line_start":195,"line_end":195,"column_start":11,"column_end":34,"is_primary":true,"text":[{"text":"    #[cfg(feature = \"bundle-pmat\")]","highlight_start":11,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected values for `feature` are: `default`, `proptest`, and `schema-generation`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider adding `bundle-pmat` as a feature in `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unexpected_cfgs)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unexpected `cfg` condition value: `bundle-pmat`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/config.rs:195:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[cfg(feature = \"bundle-pmat\")]\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected values for `feature` are: `default`, `proptest`, and `schema-generation`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: consider adding `bundle-pmat` as a feature in `Cargo.toml`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unexpected_cfgs)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"unexpected `cfg` condition value: `bundle-pmat`","code":{"code":"unexpected_cfgs","explanation":null},"level":"warning","spans":[{"file_name":"src/config.rs","byte_start":3911,"byte_end":3934,"line_start":151,"line_end":151,"column_start":15,"column_end":38,"is_primary":true,"text":[{"text":"        #[cfg(feature = \"bundle-pmat\")]","highlight_start":15,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected values for `feature` are: `default`, `proptest`, and `schema-generation`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider adding `bundle-pmat` as a feature in `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unexpected `cfg` condition value: `bundle-pmat`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/config.rs:151:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m151\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         #[cfg(feature = \"bundle-pmat\")]\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected values for `feature` are: `default`, `proptest`, and `schema-generation`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: consider adding `bundle-pmat` as a feature in `Cargo.toml`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Error as McpError`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mcp/mod.rs","byte_start":197,"byte_end":214,"line_start":5,"line_end":5,"column_start":59,"column_end":76,"is_primary":true,"text":[{"text":"use pmcp::{ServerBuilder, TypedTool, RequestHandlerExtra, Error as McpError};","highlight_start":59,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/mcp/mod.rs","byte_start":195,"byte_end":214,"line_start":5,"line_end":5,"column_start":57,"column_end":76,"is_primary":true,"text":[{"text":"use pmcp::{ServerBuilder, TypedTool, RequestHandlerExtra, Error as McpError};","highlight_start":57,"highlight_end":76}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Error as McpError`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/mcp/mod.rs:5:59\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use pmcp::{ServerBuilder, TypedTool, RequestHandlerExtra, Error as McpError};\n  \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `DelegateTaskArgs: schemars::JsonSchema` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/mcp/mod.rs","byte_start":3308,"byte_end":3709,"line_start":102,"line_end":110,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                TypedTool::new(\"delegate_task\", {","highlight_start":17,"highlight_end":50},{"text":"                    let executor = executor.clone();","highlight_start":1,"highlight_end":53},{"text":"                    move |args: DelegateTaskArgs, _extra: RequestHandlerExtra| {","highlight_start":1,"highlight_end":81},{"text":"                        let executor = executor.clone();","highlight_start":1,"highlight_end":57},{"text":"                        Box::pin(async move {","highlight_start":1,"highlight_end":46},{"text":"                            executor.delegate_task(args).await","highlight_start":1,"highlight_end":63},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                })","highlight_start":1,"highlight_end":19}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `schemars::JsonSchema` is not implemented for `DelegateTaskArgs`","code":null,"level":"help","spans":[{"file_name":"src/mcp/mod.rs","byte_start":643,"byte_end":670,"line_start":21,"line_end":21,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct DelegateTaskArgs {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `schemars` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-1.2.1/src/lib.rs","byte_start":3834,"byte_end":3854,"line_start":135,"line_end":135,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"pub trait JsonSchema {","highlight_start":1,"highlight_end":21}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-0.8.22/src/lib.rs","byte_start":4222,"byte_end":4242,"line_start":133,"line_end":133,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub trait JsonSchema {","highlight_start":1,"highlight_end":21}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `schemars::JsonSchema`:\n  &'a T\n  &'a mut T\n  ()\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\n  (T0, T1, T2, T3, T4, T5)\nand 133 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `TypedTool::<T, F>::new`","code":null,"level":"note","spans":[{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmcp-1.9.4/src/server/typed_tool.rs","byte_start":2075,"byte_end":2078,"line_start":67,"line_end":67,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn new(name: impl Into<String>, handler: F) -> Self","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmcp-1.9.4/src/server/typed_tool.rs","byte_start":2145,"byte_end":2155,"line_start":69,"line_end":69,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"        T: JsonSchema,","highlight_start":12,"highlight_end":22}],"label":"required by this bound in `TypedTool::<T, F>::new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `DelegateTaskArgs: schemars::JsonSchema` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mcp/mod.rs:102:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                 TypedTool::new(\"delegate_task\", {\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     let executor = executor.clone();\n\u001b[1m\u001b[94m104\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     move |args: DelegateTaskArgs, _extra: RequestHandlerExtra| {\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         let executor = executor.clone();\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 })\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `schemars::JsonSchema` is not implemented for `DelegateTaskArgs`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mcp/mod.rs:21:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct DelegateTaskArgs {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `schemars` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-1.2.1/src/lib.rs:135:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait JsonSchema {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-0.8.22/src/lib.rs:133:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m133\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait JsonSchema {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `schemars::JsonSchema`:\n              &'a T\n              &'a mut T\n              ()\n              (T0, T1)\n              (T0, T1, T2)\n              (T0, T1, T2, T3)\n              (T0, T1, T2, T3, T4)\n              (T0, T1, T2, T3, T4, T5)\n            and 133 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `TypedTool::<T, F>::new`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmcp-1.9.4/src/server/typed_tool.rs:69:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(name: impl Into<String>, handler: F) -> Self\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n \u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n \u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: JsonSchema,\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `TypedTool::<T, F>::new`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `AgentStatusArgs: schemars::JsonSchema` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/mcp/mod.rs","byte_start":3912,"byte_end":4347,"line_start":116,"line_end":124,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                TypedTool::new(\"agent_status\", {","highlight_start":17,"highlight_end":49},{"text":"                    let agent_registry = agent_registry.clone();","highlight_start":1,"highlight_end":65},{"text":"                    move |args: AgentStatusArgs, _extra: RequestHandlerExtra| {","highlight_start":1,"highlight_end":80},{"text":"                        let agent_registry = agent_registry.clone();","highlight_start":1,"highlight_end":69},{"text":"                        Box::pin(async move {","highlight_start":1,"highlight_end":46},{"text":"                            query_agent_status(agent_registry, args).await","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                })","highlight_start":1,"highlight_end":19}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `schemars::JsonSchema` is not implemented for `AgentStatusArgs`","code":null,"level":"help","spans":[{"file_name":"src/mcp/mod.rs","byte_start":1527,"byte_end":1553,"line_start":50,"line_end":50,"column_start":1,"column_end":27,"is_primary":true,"text":[{"text":"pub struct AgentStatusArgs {","highlight_start":1,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `schemars` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-1.2.1/src/lib.rs","byte_start":3834,"byte_end":3854,"line_start":135,"line_end":135,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"pub trait JsonSchema {","highlight_start":1,"highlight_end":21}],"label":"this is the expected trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-0.8.22/src/lib.rs","byte_start":4222,"byte_end":4242,"line_start":133,"line_end":133,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub trait JsonSchema {","highlight_start":1,"highlight_end":21}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `schemars::JsonSchema`:\n  &'a T\n  &'a mut T\n  ()\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\n  (T0, T1, T2, T3, T4, T5)\nand 133 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `TypedTool::<T, F>::new`","code":null,"level":"note","spans":[{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmcp-1.9.4/src/server/typed_tool.rs","byte_start":2075,"byte_end":2078,"line_start":67,"line_end":67,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn new(name: impl Into<String>, handler: F) -> Self","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmcp-1.9.4/src/server/typed_tool.rs","byte_start":2145,"byte_end":2155,"line_start":69,"line_end":69,"column_start":12,"column_end":22,"is_primary":true,"text":[{"text":"        T: JsonSchema,","highlight_start":12,"highlight_end":22}],"label":"required by this bound in `TypedTool::<T, F>::new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `AgentStatusArgs: schemars::JsonSchema` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mcp/mod.rs:116:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                 TypedTool::new(\"agent_status\", {\n\u001b[1m\u001b[94m117\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     let agent_registry = agent_registry.clone();\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     move |args: AgentStatusArgs, _extra: RequestHandlerExtra| {\n\u001b[1m\u001b[94m119\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         let agent_registry = agent_registry.clone();\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 })\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `schemars::JsonSchema` is not implemented for `AgentStatusArgs`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mcp/mod.rs:50:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentStatusArgs {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: there are multiple different versions of crate `schemars` in the dependency graph\n   \u001b[1m\u001b[94m--> \u001b[0m/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-1.2.1/src/lib.rs:135:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait JsonSchema {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the expected trait\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/schemars-0.8.22/src/lib.rs:133:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m133\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait JsonSchema {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: you can use `cargo tree` to explore your dependency tree\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `schemars::JsonSchema`:\n              &'a T\n              &'a mut T\n              ()\n              (T0, T1)\n              (T0, T1, T2)\n              (T0, T1, T2, T3)\n              (T0, T1, T2, T3, T4)\n              (T0, T1, T2, T3, T4, T5)\n            and 133 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `TypedTool::<T, F>::new`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/bill/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmcp-1.9.4/src/server/typed_tool.rs:69:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(name: impl Into<String>, handler: F) -> Self\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n \u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n \u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: JsonSchema,\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `TypedTool::<T, F>::new`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `{async block@src/mcp/mod.rs:120:34: 120:44}` to be a future that resolves to `Result<Value, Error>`, but it resolves to `Result<AgentStatusOutput, Error>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/mcp/mod.rs","byte_start":4183,"byte_end":4306,"line_start":120,"line_end":122,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"                        Box::pin(async move {","highlight_start":25,"highlight_end":46},{"text":"                            query_agent_status(agent_registry, args).await","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27}],"label":"expected `Result<Value, Error>`, found `Result<AgentStatusOutput, Error>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::result::Result<serde_json::Value, _>`\n   found enum `std::result::Result<AgentStatusOutput, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for the cast from `Pin<Box<{async block@src/mcp/mod.rs:120:34: 120:44}>>` to `Pin<Box<dyn Future<Output = ...> + Send>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/bill/dev/tools/extension/agents-manager/target/release/deps/bl1nk_agents_manager-d2ec8260687b1df1.long-type-15908542996688077798.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0271]\u001b[0m\u001b[1m: expected `{async block@src/mcp/mod.rs:120:34: 120:44}` to be a future that resolves to `Result<Value, Error>`, but it resolves to `Result<AgentStatusOutput, Error>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mcp/mod.rs:120:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                         Box::pin(async move {\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             query_agent_status(agent_registry, args).await\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         })\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Result<Value, Error>`, found `Result<AgentStatusOutput, Error>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::result::Result<\u001b[1m\u001b[35mserde_json::Value\u001b[0m, _>`\n               found enum `std::result::Result<\u001b[1m\u001b[35mAgentStatusOutput\u001b[0m, _>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for the cast from `Pin<Box<{async block@src/mcp/mod.rs:120:34: 120:44}>>` to `Pin<Box<dyn Future<Output = ...> + Send>>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/bill/dev/tools/extension/agents-manager/target/release/deps/bl1nk_agents_manager-d2ec8260687b1df1.long-type-15908542996688077798.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/mcp/mod.rs","byte_start":4789,"byte_end":4797,"line_start":142,"line_end":142,"column_start":23,"column_end":31,"is_primary":false,"text":[{"text":"        active_tasks: registry.active_task_count(),","highlight_start":23,"highlight_end":31}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/mcp/mod.rs","byte_start":4705,"byte_end":4713,"line_start":139,"line_end":139,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    let registry = registry.read().await;","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving `registry` an explicit type","code":null,"level":"help","spans":[{"file_name":"src/mcp/mod.rs","byte_start":4713,"byte_end":4713,"line_start":139,"line_end":139,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    let registry = registry.read().await;","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mcp/mod.rs:139:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let registry = registry.read().await;\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m142\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         active_tasks: registry.active_task_count(),\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `registry` an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let registry\u001b[92m: /* Type */\u001b[0m = registry.read().await;\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/config.rs","byte_start":3729,"byte_end":3739,"line_start":147,"line_end":147,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        let mut config: Config = toml::from_str(&content)","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/config.rs","byte_start":3729,"byte_end":3733,"line_start":147,"line_end":147,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut config: Config = toml::from_str(&content)","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/config.rs:147:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m147\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut config: Config = toml::from_str(&content)\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m----\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94mhelp: remove this `mut`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors; 5 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 5 previous errors; 5 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0271, E0277, E0282, E0583.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0271, E0277, E0282, E0583.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0271`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0271`.\u001b[0m\n"}
